<link rel="import" href="../../../bower_components/polymer/polymer.html">

<script>
    NylonInputMixin = Parent => class TestMixin extends Parent {

        // listeners: {
        //     'addon-attached': '_onAddonAttached',
        // }

        // keyBindings: {
        //     'shift+tab:keydown': '_onShiftTabDown'
        // }

        // hostAttributes: {
        //     tabindex: 0
        // }
        static get inputElement() {
            return this.$.input;
        }

        /**
         * Returns a reference to the focusable element.
         */
        static get _focusableElement() {
            return this.inputElement;
        }

        created() {
            // These types have some default placeholder text; overlapping
            // the label on top of it looks terrible. Auto-float the label in this case.
            this._typesThatHaveText = ["date", "datetime", "datetime-local", "month",
                "time", "week", "file"];
        }

        attached() {
            this._updateAriaLabelledBy();

            // In the 2.0 version of the element, this is handled in `onIronInputReady`,
            // i.e. after the native input has finished distributing. In the 1.0 version,
            // the input is in the shadow tree, so it's already available.
            if (!Polymer.Element && this.inputElement &&
                this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
                this.alwaysFloatLabel = true;
            }
        }

        _appendStringWithSpace(str, more) {
            if (str) {
                str = str + ' ' + more;
            } else {
                str = more;
            }
            return str;
        }

        _onAddonAttached(event) {
            var target = Polymer.dom(event).rootTarget;
            if (target.id) {
                this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
            } else {
                var id = 'paper-input-add-on-' + Polymer.PaperInputHelper.NextAddonID++;
                target.id = id;
                this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
            }
        }

        /**
         * Validates the input element and sets an error style if needed.
         *
         * @return {boolean}
         */
        validate() {
            console.log(1111);
            return this.inputElement.validate();
        }

        /**
         * Forward focus to inputElement. Overriden from IronControlState.
         */
        _focusBlurHandler(event) {
            Polymer.IronControlState._focusBlurHandler.call(this, event);

            // Forward the focus to the nested input.
            if (this.focused && !this._shiftTabPressed && this._focusableElement) {
                this._focusableElement.focus();
            }
        }

        /**
         * Handler that is called when a shift+tab keypress is detected by the menu.
         *
         * @param {CustomEvent} event A key combination event.
         */
        _onShiftTabDown(event) {
            var oldTabIndex = this.getAttribute('tabindex');
            this._shiftTabPressed = true;
            this.setAttribute('tabindex', '-1');
            this.async(function () {
                this.setAttribute('tabindex', oldTabIndex);
                this._shiftTabPressed = false;
            }, 1);
        }

        /**
         * If `autoValidate` is true, then validates the element.
         */
        _handleAutoValidate() {
            if (this.autoValidate)
                this.validate();
        }

        /**
         * Restores the cursor to its original position after updating the value.
         * @param {string} newValue The value that should be saved.
         */
        updateValueAndPreserveCaret(newValue) {
            // Not all elements might have selection, and even if they have the
            // right properties, accessing them might throw an exception (like for
            // <input type=number>)
            try {
                var start = this.inputElement.selectionStart;
                this.value = newValue;

                // The cursor automatically jumps to the end after re-setting the value,
                // so restore it to its original position.
                this.inputElement.selectionStart = start;
                this.inputElement.selectionEnd = start;
            } catch (e) {
                // Just set the value and give up on the caret.
                this.value = newValue;
            }
        }

        _computeAlwaysFloatLabel(alwaysFloatLabel, placeholder) {
            return placeholder || alwaysFloatLabel;
        }

        _updateAriaLabelledBy() {
            var label = Polymer.dom(this.root).querySelector('label');
            if (!label) {
                this._ariaLabelledBy = '';
                return;
            }
            var labelledBy;
            if (label.id) {
                labelledBy = label.id;
            } else {
                labelledBy = 'paper-input-label-' + Polymer.PaperInputHelper.NextLabelID++;
                label.id = labelledBy;
            }
            this._ariaLabelledBy = labelledBy;
        }

        _onChange(event) {
            // In the Shadow DOM, the `change` event is not leaked into the
            // ancestor tree, so we must do this manually.
            // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
            // if (this.shadowRoot) {
            //     this.fire(event.type, { sourceEvent: event }, {
            //         node: this,
            //         bubbles: event.bubbles,
            //         cancelable: event.cancelable
            //     });
            // }
        }

        _autofocusChanged() {
            // Firefox doesn't respect the autofocus attribute if it's applied after
            // the page is loaded (Chrome/WebKit do respect it), preventing an
            // autofocus attribute specified in markup from taking effect when the
            // element is upgraded. As a workaround, if the autofocus property is set,
            // and the focus hasn't already been moved elsewhere, we take focus.
            if (this.autofocus && this._focusableElement) {

                // In IE 11, the default document.activeElement can be the page's
                // outermost html element, but there are also cases (under the
                // polyfill?) in which the activeElement is not a real HTMLElement, but
                // just a plain object. We identify the latter case as having no valid
                // activeElement.
                var activeElement = document.activeElement;
                var isActiveElementValid = activeElement instanceof HTMLElement;

                // Has some other element has already taken the focus?
                var isSomeElementActive = isActiveElementValid &&
                    activeElement !== document.body &&
                    activeElement !== document.documentElement; /* IE 11 */
                if (!isSomeElementActive) {
                    // No specific element has taken the focus yet, so we can take it.
                    this._focusableElement.focus();
                }
            }
        }
    }

</script>